# [5489. 两球之间的磁力](https://leetcode-cn.com/problems/magnetic-force-between-two-balls/)

在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。

已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。

给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。

## 这题让我们求最大化的最小磁力，这种**最大值最小化、最小值最大化一般来说都是二分题目。因为结果一定是最小化或者最大化的，左边的是满足这个结果的但是比结果要更大或者更小，右边是不满足结果的，所以相当于结果把区间分成了两部分，一部分满足一部分不满足，这就是二分常用的性质。**

### 思路：

此处二分的目标是我们的答案，也就是说我们要找一个满足题意的最大解，所有满足题意的比这个小的解在这个解的左边，所有不满足题意的解在这个解的右边，这就是我们二分区间的“区分”。知道二分目标了，那么我们下一步就是要去找check函数了，如何让我们的这个答案划分好以上这2个区间。

**这个check的过程是一个经典贪心的思路，从前往后判断取上次比较的位置和当前位置的距离是否大于mid来判断是否放置小球，如果满足这样的贪心策略（类似区间合并会议室那题，找到一个满足的情况就放一个小球），当一轮遍历完后能放置小球的数量大于m则表示这个mid是满足题意的，那么我们要继续找一个比这个mid大的更优结果，自然mid要往右边缩（也就是l=mid）**

```c++
class Solution {
public:
    int maxDistance(vector<int>& pos, int m) {
        const int N = 1e9;
        int l = 0, r = N;
        int n = pos.size();
        sort(pos.begin(), pos.end());
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            int last = pos[0];
            int cnt = 1;
            for (int i = 1; i < n; ++i) {
                if (pos[i] - last >= mid) {
                    cnt++;
                    last = pos[i];
                }
            }
            if (cnt >= m) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return r;
    }
};
```



时间复杂度：O（nlogn）

空间复杂度：O（1）