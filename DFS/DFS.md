# DFS搜索系列题





## 岛屿系列题：

#### [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。

我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。

如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。

请返回封闭岛屿的数目。

 示例 1：

输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：
灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
示例 2：

输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
输出：1
示例 3：

输入：grid = [[1,1,1,1,1,1,1],
             [1,0,0,0,0,0,1],
             [1,0,1,1,1,0,1],
             [1,0,1,0,1,0,1],
             [1,0,1,1,1,0,1],
             [1,0,0,0,0,0,1],
             [1,1,1,1,1,1,1]]
输出：2

## 思路：

网格搜索题，该题是搜索入口是为0的点，搜索的附加条件是碰到边界的情况就终止，碰到1的情况认为是成功，当dfs递归搜索的4个方向都是1时认为全0的岛屿被

水域所包围，答案数加1.

**此题有2个点需要特别注意：**

1. **需要用一个visited的数组来避免dfs重复搜索，但是用visited数组的话，代码写起来比较冗余，此处可以用一个常用技巧，将遍历过的位置的0变成1，这样我们判断时就不会再次进行搜索，因为搜索位置值为1时我们会直接返回true，表示该方向搜索正确，是被1围绕的**
2. **搜索四个方向时不能碰到边界就返回false，此时应该把四个方向都搜索完再返回正确，反过来想，如果只搜索了部分方向剩余的方向没有搜索和标记，在外层循环判断该位置是否为0是会再次进入，这样得出的结果会多**

```c++
class Solution {
public:
    int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    bool dfs(vector<vector<int>>& grid, int x, int y) {
        if (x > grid.size() - 1 || x < 0 || y < 0 || y > grid[0].size() - 1) {
            return false;
        }
        if (grid[x][y] == 1) {
            return true;
        }
        grid[x][y] = 1;
        int res  = 0;
        for (int i = 0; i < 4; ++i) {
            res += dfs(grid, x + dir[i][0], y + dir[i][1]);
        }
        if (res == 4) {
            return true;
        } else {
            return false;
        }
    }

    int closedIsland(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (0 == grid[i][j]) {
                    if(true == dfs(grid, i, j)) {
                        ans++;
                    }
                }
            }
        }
        return ans;
    }
};
```

