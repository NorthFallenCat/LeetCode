# 区间合并

## 区间合并也是经常用到的一个方法，类似的题目有判断区间是否重合，公交车最多有多少人在车上，满足开会条件的会议室有多少个，但区间合并没有贪心的思想，基本都是从前往后遍历模拟即可

#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:

输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

## 思路：

题目意思非常清楚，让我们把有重叠的区间做一个合并，返回最后合并的结果。

很容易想到我们从第二个区间开始判断前一个区间的情况，这前一个区间不是物理上的前一个，而是前面合并完的区间结果，**如果和前一个有重叠则合并，如果没有重叠，则将当前区间作为下一个区间判断的基准。也就是说，我们在遍历区间时候会维护一个“上一个区间”的概念，维护一个start和end标记即可。**

**判断重叠的条件也非常简单：当前区间的ive[0]是否大于上一个区间的end，如果大于则重叠了**

**这里，我们要特别注意首尾的边界情况，将初始的start、end记为最大负值，这样能让我们第一个区间能作为判断的基准。每次插入到答案数组里面时我们要判断下当前要插入的start end是否是初始的最大负值（我们插入的答案都是上一个区间），当判断完成时，最后一个区间也得记得放入答案中**

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& ive) {
        sort(ive.begin(), ive.end());
        vector<int> begin(2);
        vector<vector<int>> ans;
        begin[0] = -0x3f3f3f3f;
        begin[1] = -0x3f3f3f3f;
        int st = begin[0];
        int end = begin[1];
        for (auto x : ive) {
            if (end < x[0]) {
                if (st != -0x3f3f3f3f) {
                    vector<int> tmp(2);
                    tmp[0] = st;
                    tmp[1] = end;
                    ans.push_back(tmp);
                }
                st = x[0];
                end = x[1];
            } else {
                end = max(x[1], end); // 有可能当前的区间恰好被上个区间包住了，这也算重叠
            }
        }
        if (st != -0x3f3f3f3f) {
            vector<int> tmp(2);
            tmp[0] = st;
            tmp[1] = end;
            ans.push_back(tmp);
        }
        return ans;
    }
};
```

