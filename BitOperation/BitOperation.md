# BitOperation位运算系列

## 位运算运用场景非常广泛，经常用来进行一些能打到O（1）时间复杂度的“骚操作“

## 常用的几个操作如下：

1、取某个数的某一位的值

​		(i >> k) & 1  ----------->含义为将数i的第k个数字通过右移操作变为各位，与1做与运算得出结果，**注意该结果是10000（后面有0直到末尾）**

2、取某个数的第一个1出现的位置

​		(n) & (-n)     ----------->-n的含义是n的补码，也就是n的数字位取反加1，与上n则是第一个1出现的位置

3、异或操作^

​		两个不同的数异或结果为1，相同异或结果为0（非常关键），**两个数字做异或操作也表示为两个数相加不进位！**

下面我们来看看对应上面3个操作相应的模板题。


## 题目示例：

### 题目一（对应操作二）：

#### [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

 示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。


### 思路

题目的意思非常清楚，让我们求某个数其二进制表示的1的个数，这里我们将最后一个1的位置取出后，用原来的数减去这个结果作为新的数继续判断，每次操作都将结果加1，最后输出结果即可。

```c++
class Solution {
public:
    int helper(uint32_t num) {
        int res = 0;
        while (num) {
            num -= (num & (-num));
            res++;
        }
        return res;
    }
    int hammingWeight(uint32_t n) {
        return  helper(n);
    }
};
```

类似的题目还有[338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/) 就不重复贴代码了

## 题目二（对应操作二）：

#### [762. 二进制表示中质数个计算置位](https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/)

给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。

（注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）

示例 1:

输入: L = 6, R = 10
输出: 4
解释:
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)

**注意:**

1. `L, R` 是 `L <= R` 且在 `[1, 10^6]` 中的整数。
2. `R - L` 的最大值为 10000。

### 思路：

此题跟上面题目一思路一致，需要注意的就是此题的数据范围是10^6也就是2^20次方，对应着也就是20位的数字，我们将20以内的质数直接写出，计算完每个数1的个数再判断个数是否在这个质数列表里面即可。

```c++
class Solution {
public:
    int helper(int num) {
        int res = 0;
        while (num) {
			num -= num & (-num);
            res++;
        }
        return res;
    }
    int countPrimeSetBits(int L, int R) {
        vector<int> arr;
        set<int> s{2, 3, 5, 7, 11, 13, 17, 19};
		for (int i = L; i <= R; ++i) {
            arr.push_back(helper(i));
        }
        int ans = 0;
        for (auto x : arr) {
            if (s.count(x)) {
                ans++;
            }
        }
        return ans;
    }
};
```

## 题目三（对应操作三）：

#### [476. 数字的补数](https://leetcode-cn.com/problems/number-complement/)

给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

示例 1:

输入: 5
输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
示例 2:

输入: 1
输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。


注意:

给定的整数保证在 32 位带符号整数的范围内。
你可以假定二进制数不包含前导零位。

### 思路：

这题让我们取某个正整数的反码，不用考虑负数的情况下，还是比较简单的。补数就是对这个数所有的二进制位全部做取反操作，一种方法是通过操作1的方式遍历每个数，依次取反，然后用一个数左移保存起来。这边我们使用异或操作来解这道题，异或相当于不进位的加，我们可以发现整数和他的补数加起来正好是111（1的个数为两个数的除了前导零1的个数），利用这个性质，我们将这个正整数跟全1做异或操作能够直接得出结果。

```c++
class Solution {
public:
    int findComplement(int num) {
        int idx = 0;
        int a = num;
        int ans = 0;
        while (a >> idx) {
            idx++;
        }
        int helper = 1;
        int cnt = 1;
        while (cnt < idx) {
            helper <<= 1;
            helper += 1;
            cnt++;
        }
        return a ^ helper;
    }
};
```

